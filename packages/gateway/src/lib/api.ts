/* tslint:disable */
/* eslint-disable */
/**
 * Gateway interaction
 * Explore the functionality of an gateway
 *
 * The version of the OpenAPI document: 1.0.0 - $GITHUB_SHA
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Compression
 */
export interface Compression {
    /**
     * 
     * @type {CompressionType}
     * @memberof Compression
     */
    'type': CompressionType;
    /**
     * Json encoded information that are required for this kind of compression.
     * @type {string}
     * @memberof Compression
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompressionType = {
    JSON: 'JSON',
    PROTO: 'PROTO'
} as const;

export type CompressionType = typeof CompressionType[keyof typeof CompressionType];


/**
 * 
 * @export
 * @interface ControllerManage
 */
export interface ControllerManage {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    'add'?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateDidIdDto
 */
export interface CreateDidIdDto {
    /**
     * Identifier that belongs to the public key
     * @type {string}
     * @memberof CreateDidIdDto
     */
    'identifier': string;
    /**
     * Invite code that allows the creation of a certificate that includes the public key of the identifier.
     * @type {string}
     * @memberof CreateDidIdDto
     */
    'secret': string;
    /**
     * 
     * @type {CreateDidIdDtoPublicKey}
     * @memberof CreateDidIdDto
     */
    'publicKey': CreateDidIdDtoPublicKey;
}
/**
 * Value of the public key as a json web key.
 * @export
 * @interface CreateDidIdDtoPublicKey
 */
export interface CreateDidIdDtoPublicKey {
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'kty'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'n'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'e'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'alg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'crv'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'd'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'dp'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'dq'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'k'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'p'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'qi'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'x'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDidIdDtoPublicKey
     */
    'y'?: string;
}
/**
 * 
 * @export
 * @interface DidHashStructure
 */
export interface DidHashStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidHashStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidHashStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof DidHashStructure
     */
    'algorithm'?: DidHashStructureAlgorithm;
    /**
     * if set to a date it will revoke the hash
     * @type {string}
     * @memberof DidHashStructure
     */
    'revoked'?: string;
}

export const DidHashStructureAlgorithm = {
    sha256: 'sha256'
} as const;

export type DidHashStructureAlgorithm = typeof DidHashStructureAlgorithm[keyof typeof DidHashStructureAlgorithm];

/**
 * Did that controls this did.
 * @export
 * @interface DidHashStructureController
 */
export interface DidHashStructureController {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof DidHashStructureController
     */
    'add'?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof DidHashStructureController
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DidIdStructure
 */
export interface DidIdStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidIdStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidIdStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidIdStructure
     */
    'role'?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidIdStructure
     */
    'verificationMethod'?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidIdStructure
     */
    'service'?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'authentication'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'assertionMethod'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'keyAgreement'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'modification'?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidIdTransactionBody
 */
export interface DidIdTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof DidIdTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof DidIdTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof DidIdTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {DidIdTransactionBodyValue}
     * @memberof DidIdTransactionBody
     */
    'value': DidIdTransactionBodyValue;
}
/**
 * elements of the did document
 * @export
 * @interface DidIdTransactionBodyValue
 */
export interface DidIdTransactionBodyValue {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidIdTransactionBodyValue
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidIdTransactionBodyValue
     */
    'controller'?: DidHashStructureController;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidIdTransactionBodyValue
     */
    'role'?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidIdTransactionBodyValue
     */
    'verificationMethod'?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidIdTransactionBodyValue
     */
    'service'?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'authentication'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'assertionMethod'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'keyAgreement'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'modification'?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidIdTransactionDto
 */
export interface DidIdTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof DidIdTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {DidIdTransactionBody}
     * @memberof DidIdTransactionDto
     */
    'body': DidIdTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof DidIdTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof DidIdTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface DidPublicKey
 */
export interface DidPublicKey {
    /**
     * unique identifier of a key
     * @type {string}
     * @memberof DidPublicKey
     */
    'id': string;
    /**
     * 
     * @type {DidPublicKeyPublicKeyJwk}
     * @memberof DidPublicKey
     */
    'publicKeyJwk': DidPublicKeyPublicKeyJwk;
    /**
     * controller of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    'controller': string;
    /**
     * 
     * @type {DidPublicKeyType}
     * @memberof DidPublicKey
     */
    'type': DidPublicKeyType;
}
/**
 * encoded key value
 * @export
 * @interface DidPublicKeyPublicKeyJwk
 */
export interface DidPublicKeyPublicKeyJwk {
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'kty'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'n'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'e'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'alg'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'crv'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'd'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'dp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'dq'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'k'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'p'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'qi'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'x'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'y'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DidPublicKeyType = {
    RsaVerificationKey2018: 'RsaVerificationKey2018'
} as const;

export type DidPublicKeyType = typeof DidPublicKeyType[keyof typeof DidPublicKeyType];


/**
 * 
 * @export
 * @interface DidResponse
 */
export interface DidResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof DidResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {DidIdTransactionDto}
     * @memberof DidResponse
     */
    'transaction': DidIdTransactionDto;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DidRoles = {
    Validator: 'Validator',
    Gateway: 'Gateway',
    Observer: 'Observer',
    Client: 'Client'
} as const;

export type DidRoles = typeof DidRoles[keyof typeof DidRoles];


/**
 * 
 * @export
 * @interface DidSchemaStructure
 */
export interface DidSchemaStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidSchemaStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidSchemaStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * json schema to validate the data that should be parsed into the
     * @type {string}
     * @memberof DidSchemaStructure
     */
    'schema'?: string;
}
/**
 * 
 * @export
 * @interface DidService
 */
export interface DidService {
    /**
     * unique identifier of a service
     * @type {string}
     * @memberof DidService
     */
    'id': string;
    /**
     * name of the service
     * @type {string}
     * @memberof DidService
     */
    'type': string;
    /**
     * url to the service
     * @type {string}
     * @memberof DidService
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface DidStatusListStructure
 */
export interface DidStatusListStructure {
    /**
     * unique identifier of a statuslist
     * @type {string}
     * @memberof DidStatusListStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidStatusListStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * enocded bitstring
     * @type {string}
     * @memberof DidStatusListStructure
     */
    'encodedList'?: string;
    /**
     * 
     * @type {StatusPurpose}
     * @memberof DidStatusListStructure
     */
    'statusPurpose'?: StatusPurpose;
}
/**
 * 
 * @export
 * @interface DidTemplateStructure
 */
export interface DidTemplateStructure {
    /**
     * unique identifier of a template
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidTemplateStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * template that should be used.
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'template'?: string;
    /**
     * did of the schema the template is based on
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'schemaId'?: string;
    /**
     * 
     * @type {Compression}
     * @memberof DidTemplateStructure
     */
    'compression'?: Compression;
}
/**
 * 
 * @export
 * @interface DidVisualRepresentationStructure
 */
export interface DidVisualRepresentationStructure {
    /**
     * unique identifier of a visualrepresentation
     * @type {string}
     * @memberof DidVisualRepresentationStructure
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof DidVisualRepresentationStructure
     */
    'controller'?: DidHashStructureController;
    /**
     * 
     * @type {DidVisualRepresentationStructurePresentation}
     * @memberof DidVisualRepresentationStructure
     */
    'presentation'?: DidVisualRepresentationStructurePresentation;
}
/**
 * Presentation that should be connected with the did.
 * @export
 * @interface DidVisualRepresentationStructurePresentation
 */
export interface DidVisualRepresentationStructurePresentation {
    /**
     * List of presentations that should be added to the did document.
     * @type {Array<Presentation>}
     * @memberof DidVisualRepresentationStructurePresentation
     */
    'add'?: Array<Presentation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DidVisualRepresentationStructurePresentation
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface HashDidTransactionDto
 */
export interface HashDidTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof HashDidTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {HashTransactionBody}
     * @memberof HashDidTransactionDto
     */
    'body': HashTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof HashDidTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof HashDidTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface HashResponse
 */
export interface HashResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof HashResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {HashResponseTransaction}
     * @memberof HashResponse
     */
    'transaction': HashResponseTransaction;
}
/**
 * additional metadata to the transaction
 * @export
 * @interface HashResponseMetaData
 */
export interface HashResponseMetaData {
    /**
     * 
     * @type {PersistedTransactionMetaData}
     * @memberof HashResponseMetaData
     */
    'transaction': PersistedTransactionMetaData;
    /**
     * 
     * @type {PersistedBlock}
     * @memberof HashResponseMetaData
     */
    'block': PersistedBlock;
}
/**
 * transaction that was persisted.
 * @export
 * @interface HashResponseTransaction
 */
export interface HashResponseTransaction {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof HashResponseTransaction
     */
    'version': number;
    /**
     * 
     * @type {HashTransactionBody}
     * @memberof HashResponseTransaction
     */
    'body': HashTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof HashResponseTransaction
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof HashResponseTransaction
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface HashTransactionBody
 */
export interface HashTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof HashTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof HashTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof HashTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {HashTransactionBodyValue}
     * @memberof HashTransactionBody
     */
    'value': HashTransactionBodyValue;
}
/**
 * elements of the did document
 * @export
 * @interface HashTransactionBodyValue
 */
export interface HashTransactionBodyValue {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof HashTransactionBodyValue
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof HashTransactionBodyValue
     */
    'controller'?: DidHashStructureController;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof HashTransactionBodyValue
     */
    'algorithm'?: HashTransactionBodyValueAlgorithm;
    /**
     * if set to a date it will revoke the hash
     * @type {string}
     * @memberof HashTransactionBodyValue
     */
    'revoked'?: string;
}

export const HashTransactionBodyValueAlgorithm = {
    sha256: 'sha256'
} as const;

export type HashTransactionBodyValueAlgorithm = typeof HashTransactionBodyValueAlgorithm[keyof typeof HashTransactionBodyValueAlgorithm];

/**
 * 
 * @export
 * @interface InviteNode
 */
export interface InviteNode {
    /**
     * id of the did
     * @type {string}
     * @memberof InviteNode
     */
    'id': string;
    /**
     * Secret token
     * @type {string}
     * @memberof InviteNode
     */
    'secret': string;
    /**
     * Url of the node endpoint
     * @type {string}
     * @memberof InviteNode
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * Unique identifier that is used for the new did.
     * @type {string}
     * @memberof InviteRequest
     */
    'id'?: string;
    /**
     * Secret that is used for authentication
     * @type {string}
     * @memberof InviteRequest
     */
    'secret'?: string;
    /**
     * Unique identifier that will be stored to identify the did with a human readable name.
     * @type {string}
     * @memberof InviteRequest
     */
    'name': string;
    /**
     * Describes for what type of role in the network the secret is allowed to be used
     * @type {string}
     * @memberof InviteRequest
     */
    'role': InviteRequestRole;
    /**
     * If set to true a new secret will be set for an existing entry
     * @type {boolean}
     * @memberof InviteRequest
     */
    'force'?: boolean;
}

export const InviteRequestRole = {
    Validator: 'Validator',
    Gateway: 'Gateway',
    Observer: 'Observer',
    Client: 'Client'
} as const;

export type InviteRequestRole = typeof InviteRequestRole[keyof typeof InviteRequestRole];

/**
 * 
 * @export
 * @interface PersistedBlock
 */
export interface PersistedBlock {
    /**
     * 
     * @type {number}
     * @memberof PersistedBlock
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PersistedBlock
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersistedBlock
     */
    'validators': Array<string>;
}
/**
 * 
 * @export
 * @interface PersistedTransaction
 */
export interface PersistedTransaction {
    /**
     * 
     * @type {PersistedTransactionMetaData}
     * @memberof PersistedTransaction
     */
    'transaction': PersistedTransactionMetaData;
    /**
     * 
     * @type {PersistedBlock}
     * @memberof PersistedTransaction
     */
    'block': PersistedBlock;
}
/**
 * 
 * @export
 * @interface PersistedTransactionMetaData
 */
export interface PersistedTransactionMetaData {
    /**
     * 
     * @type {string}
     * @memberof PersistedTransactionMetaData
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof PersistedTransactionMetaData
     */
    'persisted': string;
}
/**
 * 
 * @export
 * @interface Presentation
 */
export interface Presentation {
    /**
     * unique identifier of a presentation
     * @type {string}
     * @memberof Presentation
     */
    'id': string;
    /**
     * 
     * @type {PresentationType}
     * @memberof Presentation
     */
    'type': PresentationType;
    /**
     * resolvable link to request the content
     * @type {string}
     * @memberof Presentation
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface PresentationMange
 */
export interface PresentationMange {
    /**
     * List of presentations that should be added to the did document.
     * @type {Array<Presentation>}
     * @memberof PresentationMange
     */
    'add'?: Array<Presentation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PresentationMange
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PresentationType = {
    pdf: 'pdf',
    html: 'html'
} as const;

export type PresentationType = typeof PresentationType[keyof typeof PresentationType];


/**
 * 
 * @export
 * @interface PublicKeyJwkDto
 */
export interface PublicKeyJwkDto {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'kty'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'n'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'e'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'alg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'crv'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'd'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'dp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'dq'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'k'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'p'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'qi'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'x'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'y'?: string;
}
/**
 * 
 * @export
 * @interface RoleManage
 */
export interface RoleManage {
    /**
     * roles that should be added to the did
     * @type {Array<DidRoles>}
     * @memberof RoleManage
     */
    'add'?: Array<DidRoles>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SchemaResponse
 */
export interface SchemaResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof SchemaResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {SchemaResponseTransaction}
     * @memberof SchemaResponse
     */
    'transaction': SchemaResponseTransaction;
}
/**
 * transaction that was persisted.
 * @export
 * @interface SchemaResponseTransaction
 */
export interface SchemaResponseTransaction {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof SchemaResponseTransaction
     */
    'version': number;
    /**
     * 
     * @type {SchemaTransactionBody}
     * @memberof SchemaResponseTransaction
     */
    'body': SchemaTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof SchemaResponseTransaction
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof SchemaResponseTransaction
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface SchemaTransactionBody
 */
export interface SchemaTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof SchemaTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof SchemaTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof SchemaTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {DidSchemaStructure}
     * @memberof SchemaTransactionBody
     */
    'value': DidSchemaStructure;
}
/**
 * 
 * @export
 * @interface SchemaTransactionDto
 */
export interface SchemaTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof SchemaTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {SchemaTransactionBody}
     * @memberof SchemaTransactionDto
     */
    'body': SchemaTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof SchemaTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof SchemaTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface ServiceMange
 */
export interface ServiceMange {
    /**
     * List of services that should be added to the did document.
     * @type {Array<DidService>}
     * @memberof ServiceMange
     */
    'add'?: Array<DidService>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceMange
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * Identifier of the issuer and the used key
     * @type {string}
     * @memberof SignatureDto
     */
    'identifier': string;
    /**
     * The actual signature as a hex encoded string.
     * @type {string}
     * @memberof SignatureDto
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SignatureInfo
 */
export interface SignatureInfo {
    /**
     * 
     * @type {SignatureType}
     * @memberof SignatureInfo
     */
    'type': SignatureType;
    /**
     * signature of the document values
     * @type {Array<SignatureDto>}
     * @memberof SignatureInfo
     */
    'values': Array<SignatureDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SignatureType = {
    Single: 'Single',
    Multi: 'Multi'
} as const;

export type SignatureType = typeof SignatureType[keyof typeof SignatureType];


/**
 * 
 * @export
 * @interface StatusListResponse
 */
export interface StatusListResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof StatusListResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {StatusListResponseTransaction}
     * @memberof StatusListResponse
     */
    'transaction': StatusListResponseTransaction;
}
/**
 * transaction that was persisted.
 * @export
 * @interface StatusListResponseTransaction
 */
export interface StatusListResponseTransaction {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof StatusListResponseTransaction
     */
    'version': number;
    /**
     * 
     * @type {StatusListTransactionBody}
     * @memberof StatusListResponseTransaction
     */
    'body': StatusListTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof StatusListResponseTransaction
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof StatusListResponseTransaction
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface StatusListTransactionBody
 */
export interface StatusListTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof StatusListTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof StatusListTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof StatusListTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {DidStatusListStructure}
     * @memberof StatusListTransactionBody
     */
    'value': DidStatusListStructure;
}
/**
 * 
 * @export
 * @interface StatusListTransactionDto
 */
export interface StatusListTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof StatusListTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {StatusListTransactionBody}
     * @memberof StatusListTransactionDto
     */
    'body': StatusListTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof StatusListTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof StatusListTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatusPurpose = {
    revocation: 'revocation',
    suspension: 'suspension'
} as const;

export type StatusPurpose = typeof StatusPurpose[keyof typeof StatusPurpose];


/**
 * 
 * @export
 * @interface TemplateResponse
 */
export interface TemplateResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof TemplateResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {TemplateResponseTransaction}
     * @memberof TemplateResponse
     */
    'transaction': TemplateResponseTransaction;
}
/**
 * transaction that was persisted.
 * @export
 * @interface TemplateResponseTransaction
 */
export interface TemplateResponseTransaction {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof TemplateResponseTransaction
     */
    'version': number;
    /**
     * 
     * @type {TemplateTransactionBody}
     * @memberof TemplateResponseTransaction
     */
    'body': TemplateTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TemplateResponseTransaction
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof TemplateResponseTransaction
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface TemplateTransactionBody
 */
export interface TemplateTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof TemplateTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof TemplateTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TemplateTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {DidTemplateStructure}
     * @memberof TemplateTransactionBody
     */
    'value': DidTemplateStructure;
}
/**
 * 
 * @export
 * @interface TemplateTransactionDto
 */
export interface TemplateTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof TemplateTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {TemplateTransactionBody}
     * @memberof TemplateTransactionDto
     */
    'body': TemplateTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TemplateTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof TemplateTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * Version number of the metadata.
     * @type {number}
     * @memberof TransactionMetadata
     */
    'version': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Hash: 'Hash',
    Did: 'Did',
    Schema: 'Schema',
    Template: 'Template',
    StatusList: 'StatusList',
    VisualRepresentation: 'VisualRepresentation'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface VerificationMethod
 */
export interface VerificationMethod {
    /**
     * List of public keys that should be added to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof VerificationMethod
     */
    'add'?: Array<DidPublicKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationMethod
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerificationRelationshipManage
 */
export interface VerificationRelationshipManage {
    /**
     * id that should be removed from the list
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    'add'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VisualRepresentationResponse
 */
export interface VisualRepresentationResponse {
    /**
     * 
     * @type {HashResponseMetaData}
     * @memberof VisualRepresentationResponse
     */
    'metaData': HashResponseMetaData;
    /**
     * 
     * @type {VisualRepresentationResponseTransaction}
     * @memberof VisualRepresentationResponse
     */
    'transaction': VisualRepresentationResponseTransaction;
}
/**
 * transaction that was persisted.
 * @export
 * @interface VisualRepresentationResponseTransaction
 */
export interface VisualRepresentationResponseTransaction {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof VisualRepresentationResponseTransaction
     */
    'version': number;
    /**
     * 
     * @type {VisualRepresentationTransactionBody}
     * @memberof VisualRepresentationResponseTransaction
     */
    'body': VisualRepresentationTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof VisualRepresentationResponseTransaction
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof VisualRepresentationResponseTransaction
     */
    'signature': SignatureInfo;
}
/**
 * 
 * @export
 * @interface VisualRepresentationTransactionBody
 */
export interface VisualRepresentationTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof VisualRepresentationTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof VisualRepresentationTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {VisualRepresentationTransactionBodyValue}
     * @memberof VisualRepresentationTransactionBody
     */
    'value': VisualRepresentationTransactionBodyValue;
    /**
     * 
     * @type {TransactionType}
     * @memberof VisualRepresentationTransactionBody
     */
    'type': TransactionType;
}
/**
 * unique identifier of a visualrepresentation
 * @export
 * @interface VisualRepresentationTransactionBodyValue
 */
export interface VisualRepresentationTransactionBodyValue {
    /**
     * unique identifier of a visualrepresentation
     * @type {string}
     * @memberof VisualRepresentationTransactionBodyValue
     */
    'id': string;
    /**
     * 
     * @type {DidHashStructureController}
     * @memberof VisualRepresentationTransactionBodyValue
     */
    'controller'?: DidHashStructureController;
    /**
     * 
     * @type {DidVisualRepresentationStructurePresentation}
     * @memberof VisualRepresentationTransactionBodyValue
     */
    'presentation'?: DidVisualRepresentationStructurePresentation;
}
/**
 * 
 * @export
 * @interface VisualRepresentationTransactionDto
 */
export interface VisualRepresentationTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof VisualRepresentationTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {VisualRepresentationTransactionBody}
     * @memberof VisualRepresentationTransactionDto
     */
    'body': VisualRepresentationTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof VisualRepresentationTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof VisualRepresentationTransactionDto
     */
    'signature': SignatureInfo;
}

/**
 * DefaultGatewayApi - axios parameter creator
 * @export
 */
export const DefaultGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusControllerIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultGatewayApi - functional programming interface
 * @export
 */
export const DefaultGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prometheusControllerIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prometheusControllerIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultGatewayApi - factory interface
 * @export
 */
export const DefaultGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultGatewayApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusControllerIndex(options?: any): AxiosPromise<void> {
            return localVarFp.prometheusControllerIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultGatewayApi - object-oriented interface
 * @export
 * @class DefaultGatewayApi
 * @extends {BaseAPI}
 */
export class DefaultGatewayApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultGatewayApi
     */
    public prometheusControllerIndex(options?: AxiosRequestConfig) {
        return DefaultGatewayApiFp(this.configuration).prometheusControllerIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DidGatewayApi - axios parameter creator
 * @export
 */
export const DidGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidIdDto} createDidIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerCreate: async (createDidIdDto: CreateDidIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDidIdDto' is not null or undefined
            assertParamExists('gatewayDidControllerCreate', 'createDidIdDto', createDidIdDto)
            const localVarPath = `/did/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDidIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerInvite: async (inviteRequest: InviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteRequest' is not null or undefined
            assertParamExists('gatewayDidControllerInvite', 'inviteRequest', inviteRequest)
            const localVarPath = `/did/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerResolve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gatewayDidControllerResolve', 'id', id)
            const localVarPath = `/did/resolve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidIdTransactionDto} didIdTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerStore: async (didIdTransactionDto: DidIdTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'didIdTransactionDto' is not null or undefined
            assertParamExists('gatewayDidControllerStore', 'didIdTransactionDto', didIdTransactionDto)
            const localVarPath = `/did`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(didIdTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DidGatewayApi - functional programming interface
 * @export
 */
export const DidGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DidGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidIdDto} createDidIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerCreate(createDidIdDto: CreateDidIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DidResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerCreate(createDidIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerInvite(inviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerResolve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidIdTransactionDto} didIdTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayDidControllerStore(didIdTransactionDto: DidIdTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayDidControllerStore(didIdTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DidGatewayApi - factory interface
 * @export
 */
export const DidGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DidGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Signs the public key of the Client.
         * @param {CreateDidIdDto} createDidIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerCreate(createDidIdDto: CreateDidIdDto, options?: any): AxiosPromise<DidResponse> {
            return localVarFp.gatewayDidControllerCreate(createDidIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generates an invite for a new Client
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: any): AxiosPromise<InviteNode> {
            return localVarFp.gatewayDidControllerInvite(inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resolves the name to a given did that was created by this node.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerResolve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.gatewayDidControllerResolve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds new did document to the chain.
         * @param {DidIdTransactionDto} didIdTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayDidControllerStore(didIdTransactionDto: DidIdTransactionDto, options?: any): AxiosPromise<void> {
            return localVarFp.gatewayDidControllerStore(didIdTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DidGatewayApi - object-oriented interface
 * @export
 * @class DidGatewayApi
 * @extends {BaseAPI}
 */
export class DidGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Signs the public key of the Client.
     * @param {CreateDidIdDto} createDidIdDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerCreate(createDidIdDto: CreateDidIdDto, options?: AxiosRequestConfig) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerCreate(createDidIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generates an invite for a new Client
     * @param {InviteRequest} inviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerInvite(inviteRequest: InviteRequest, options?: AxiosRequestConfig) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerInvite(inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resolves the name to a given did that was created by this node.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerResolve(id: string, options?: AxiosRequestConfig) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerResolve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds new did document to the chain.
     * @param {DidIdTransactionDto} didIdTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidGatewayApi
     */
    public gatewayDidControllerStore(didIdTransactionDto: DidIdTransactionDto, options?: AxiosRequestConfig) {
        return DidGatewayApiFp(this.configuration).gatewayDidControllerStore(didIdTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashGatewayApi - axios parameter creator
 * @export
 */
export const HashGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {HashDidTransactionDto} hashDidTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerCreate: async (hashDidTransactionDto: HashDidTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hashDidTransactionDto' is not null or undefined
            assertParamExists('gatewayHashControllerCreate', 'hashDidTransactionDto', hashDidTransactionDto)
            const localVarPath = `/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hashDidTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashGatewayApi - functional programming interface
 * @export
 */
export const HashGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {HashDidTransactionDto} hashDidTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayHashControllerCreate(hashDidTransactionDto: HashDidTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayHashControllerCreate(hashDidTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashGatewayApi - factory interface
 * @export
 */
export const HashGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new hash to the chain.
         * @param {HashDidTransactionDto} hashDidTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayHashControllerCreate(hashDidTransactionDto: HashDidTransactionDto, options?: any): AxiosPromise<HashResponse> {
            return localVarFp.gatewayHashControllerCreate(hashDidTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HashGatewayApi - object-oriented interface
 * @export
 * @class HashGatewayApi
 * @extends {BaseAPI}
 */
export class HashGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new hash to the chain.
     * @param {HashDidTransactionDto} hashDidTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashGatewayApi
     */
    public gatewayHashControllerCreate(hashDidTransactionDto: HashDidTransactionDto, options?: AxiosRequestConfig) {
        return HashGatewayApiFp(this.configuration).gatewayHashControllerCreate(hashDidTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeGatewayApi - axios parameter creator
 * @export
 */
export const NodeGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInit: async (inviteNode: InviteNode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteNode' is not null or undefined
            assertParamExists('httpGatewayControllerInit', 'inviteNode', inviteNode)
            const localVarPath = `/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteNode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerRebuild: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rebuild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerReset: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeGatewayApi - functional programming interface
 * @export
 */
export const NodeGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerInit(inviteNode: InviteNode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerInit(inviteNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerRebuild(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerRebuild(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpGatewayControllerReset(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpGatewayControllerReset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeGatewayApi - factory interface
 * @export
 */
export const NodeGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInformation(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerInit(inviteNode: InviteNode, options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerInit(inviteNode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerRebuild(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerRebuild(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpGatewayControllerReset(options?: any): AxiosPromise<void> {
            return localVarFp.httpGatewayControllerReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeGatewayApi - object-oriented interface
 * @export
 * @class NodeGatewayApi
 * @extends {BaseAPI}
 */
export class NodeGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Returns the type of the node and the service that was exposed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerInformation(options?: AxiosRequestConfig) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pass an invite code to init this node.
     * @param {InviteNode} inviteNode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerInit(inviteNode: InviteNode, options?: AxiosRequestConfig) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerInit(inviteNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebuilds the pki and hash database based on the local blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerRebuild(options?: AxiosRequestConfig) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerRebuild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeGatewayApi
     */
    public httpGatewayControllerReset(options?: AxiosRequestConfig) {
        return NodeGatewayApiFp(this.configuration).httpGatewayControllerReset(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaGatewayApi - axios parameter creator
 * @export
 */
export const SchemaGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new schema to the chain.
         * @param {SchemaTransactionDto} schemaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaySchemaControllerCreate: async (schemaTransactionDto: SchemaTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaTransactionDto' is not null or undefined
            assertParamExists('gatewaySchemaControllerCreate', 'schemaTransactionDto', schemaTransactionDto)
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaGatewayApi - functional programming interface
 * @export
 */
export const SchemaGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new schema to the chain.
         * @param {SchemaTransactionDto} schemaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewaySchemaControllerCreate(schemaTransactionDto: SchemaTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewaySchemaControllerCreate(schemaTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaGatewayApi - factory interface
 * @export
 */
export const SchemaGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new schema to the chain.
         * @param {SchemaTransactionDto} schemaTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewaySchemaControllerCreate(schemaTransactionDto: SchemaTransactionDto, options?: any): AxiosPromise<SchemaResponse> {
            return localVarFp.gatewaySchemaControllerCreate(schemaTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaGatewayApi - object-oriented interface
 * @export
 * @class SchemaGatewayApi
 * @extends {BaseAPI}
 */
export class SchemaGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new schema to the chain.
     * @param {SchemaTransactionDto} schemaTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaGatewayApi
     */
    public gatewaySchemaControllerCreate(schemaTransactionDto: SchemaTransactionDto, options?: AxiosRequestConfig) {
        return SchemaGatewayApiFp(this.configuration).gatewaySchemaControllerCreate(schemaTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatuslistGatewayApi - axios parameter creator
 * @export
 */
export const StatuslistGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new statuslist to the chain.
         * @param {StatusListTransactionDto} statusListTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayStatusListControllerCreate: async (statusListTransactionDto: StatusListTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusListTransactionDto' is not null or undefined
            assertParamExists('gatewayStatusListControllerCreate', 'statusListTransactionDto', statusListTransactionDto)
            const localVarPath = `/statuslist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusListTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatuslistGatewayApi - functional programming interface
 * @export
 */
export const StatuslistGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatuslistGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new statuslist to the chain.
         * @param {StatusListTransactionDto} statusListTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayStatusListControllerCreate(statusListTransactionDto: StatusListTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayStatusListControllerCreate(statusListTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatuslistGatewayApi - factory interface
 * @export
 */
export const StatuslistGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatuslistGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new statuslist to the chain.
         * @param {StatusListTransactionDto} statusListTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayStatusListControllerCreate(statusListTransactionDto: StatusListTransactionDto, options?: any): AxiosPromise<StatusListResponse> {
            return localVarFp.gatewayStatusListControllerCreate(statusListTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatuslistGatewayApi - object-oriented interface
 * @export
 * @class StatuslistGatewayApi
 * @extends {BaseAPI}
 */
export class StatuslistGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new statuslist to the chain.
     * @param {StatusListTransactionDto} statusListTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatuslistGatewayApi
     */
    public gatewayStatusListControllerCreate(statusListTransactionDto: StatusListTransactionDto, options?: AxiosRequestConfig) {
        return StatuslistGatewayApiFp(this.configuration).gatewayStatusListControllerCreate(statusListTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateGatewayApi - axios parameter creator
 * @export
 */
export const TemplateGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTemplateControllerCreate: async (templateTransactionDto: TemplateTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateTransactionDto' is not null or undefined
            assertParamExists('gatewayTemplateControllerCreate', 'templateTransactionDto', templateTransactionDto)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateGatewayApi - functional programming interface
 * @export
 */
export const TemplateGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayTemplateControllerCreate(templateTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateGatewayApi - factory interface
 * @export
 */
export const TemplateGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new template to the chain.
         * @param {TemplateTransactionDto} templateTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: any): AxiosPromise<TemplateResponse> {
            return localVarFp.gatewayTemplateControllerCreate(templateTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateGatewayApi - object-oriented interface
 * @export
 * @class TemplateGatewayApi
 * @extends {BaseAPI}
 */
export class TemplateGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new template to the chain.
     * @param {TemplateTransactionDto} templateTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateGatewayApi
     */
    public gatewayTemplateControllerCreate(templateTransactionDto: TemplateTransactionDto, options?: AxiosRequestConfig) {
        return TemplateGatewayApiFp(this.configuration).gatewayTemplateControllerCreate(templateTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VisualRepresentationGatewayApi - axios parameter creator
 * @export
 */
export const VisualRepresentationGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds new visualrepresentation to the chain.
         * @param {VisualRepresentationTransactionDto} visualRepresentationTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayVisualRepresentationControllerCreate: async (visualRepresentationTransactionDto: VisualRepresentationTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'visualRepresentationTransactionDto' is not null or undefined
            assertParamExists('gatewayVisualRepresentationControllerCreate', 'visualRepresentationTransactionDto', visualRepresentationTransactionDto)
            const localVarPath = `/visualrepresentation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(visualRepresentationTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisualRepresentationGatewayApi - functional programming interface
 * @export
 */
export const VisualRepresentationGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualRepresentationGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds new visualrepresentation to the chain.
         * @param {VisualRepresentationTransactionDto} visualRepresentationTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto: VisualRepresentationTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisualRepresentationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisualRepresentationGatewayApi - factory interface
 * @export
 */
export const VisualRepresentationGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisualRepresentationGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds new visualrepresentation to the chain.
         * @param {VisualRepresentationTransactionDto} visualRepresentationTransactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto: VisualRepresentationTransactionDto, options?: any): AxiosPromise<VisualRepresentationResponse> {
            return localVarFp.gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualRepresentationGatewayApi - object-oriented interface
 * @export
 * @class VisualRepresentationGatewayApi
 * @extends {BaseAPI}
 */
export class VisualRepresentationGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Adds new visualrepresentation to the chain.
     * @param {VisualRepresentationTransactionDto} visualRepresentationTransactionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualRepresentationGatewayApi
     */
    public gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto: VisualRepresentationTransactionDto, options?: AxiosRequestConfig) {
        return VisualRepresentationGatewayApiFp(this.configuration).gatewayVisualRepresentationControllerCreate(visualRepresentationTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


