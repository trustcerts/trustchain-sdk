/* tslint:disable */
/* eslint-disable */
/**
 * Observer interaction
 * Explore the functionality of a Observer
 *
 * The version of the OpenAPI document: 1.0.0 - $GITHUB_SHA
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     * id of the block
     * @type {number}
     * @memberof BlockInfo
     */
    'id': number;
    /**
     * time when the block got persisted
     * @type {string}
     * @memberof BlockInfo
     */
    'createdAt': string;
    /**
     * time when the transaction was persisted in an imported blockchain
     * @type {string}
     * @memberof BlockInfo
     */
    'imported'?: string;
}
/**
 * 
 * @export
 * @interface Compression
 */
export interface Compression {
    /**
     * 
     * @type {CompressionType}
     * @memberof Compression
     */
    'type': CompressionType;
    /**
     * Json encoded information that are required for this kind of compression.
     * @type {string}
     * @memberof Compression
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompressionType = {
    JSON: 'JSON',
    PROTO: 'PROTO'
} as const;

export type CompressionType = typeof CompressionType[keyof typeof CompressionType];


/**
 * 
 * @export
 * @interface ControllerManage
 */
export interface ControllerManage {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    'add'?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof ControllerManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DidDocument
 */
export interface DidDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidDocument
     */
    'controller': Array<string>;
}
/**
 * 
 * @export
 * @interface DidDocumentMetaData
 */
export interface DidDocumentMetaData {
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    'updated'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DidDocumentMetaData
     */
    'deactivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    'nextUpdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DidDocumentMetaData
     */
    'versionId': number;
    /**
     * 
     * @type {number}
     * @memberof DidDocumentMetaData
     */
    'nextVersionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof DidDocumentMetaData
     */
    'imported'?: string;
}
/**
 * 
 * @export
 * @interface DidHashDocument
 */
export interface DidHashDocument {
    /**
     * Hash of the file.
     * @type {string}
     * @memberof DidHashDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidHashDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidHashDocument
     */
    'controller': Array<string>;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof DidHashDocument
     */
    'algorithm': string;
    /**
     * Timestamp when the hash was revoked.
     * @type {string}
     * @memberof DidHashDocument
     */
    'revoked'?: string;
}
/**
 * 
 * @export
 * @interface DidHashStructure
 */
export interface DidHashStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidHashStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidHashStructure
     */
    'controller'?: DidStructureController;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof DidHashStructure
     */
    'algorithm'?: DidHashStructureAlgorithm;
    /**
     * if set to a date it will revoke the hash
     * @type {string}
     * @memberof DidHashStructure
     */
    'revoked'?: string;
}

export const DidHashStructureAlgorithm = {
    sha256: 'sha256'
} as const;

export type DidHashStructureAlgorithm = typeof DidHashStructureAlgorithm[keyof typeof DidHashStructureAlgorithm];

/**
 * 
 * @export
 * @interface DidHashTransaction
 */
export interface DidHashTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidHashTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidHashTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidHashTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidHashTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidHashTransactionValues}
     * @memberof DidHashTransaction
     */
    'values': DidHashTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidHashTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidHashTransaction
     */
    'id': string;
}
/**
 * Values of the transaction
 * @export
 * @interface DidHashTransactionValues
 */
export interface DidHashTransactionValues {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidHashTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidHashTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof DidHashTransactionValues
     */
    'algorithm'?: DidHashTransactionValuesAlgorithm;
    /**
     * if set to a date it will revoke the hash
     * @type {string}
     * @memberof DidHashTransactionValues
     */
    'revoked'?: string;
}

export const DidHashTransactionValuesAlgorithm = {
    sha256: 'sha256'
} as const;

export type DidHashTransactionValuesAlgorithm = typeof DidHashTransactionValuesAlgorithm[keyof typeof DidHashTransactionValuesAlgorithm];

/**
 * 
 * @export
 * @interface DidIdDocument
 */
export interface DidIdDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidIdDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidIdDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidIdDocument
     */
    'controller': Array<string>;
    /**
     * array of keys that belong to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof DidIdDocument
     */
    'verificationMethod': Array<DidPublicKey>;
    /**
     * keys that are used for authentication.
     * @type {Array<string>}
     * @memberof DidIdDocument
     */
    'authentication': Array<string>;
    /**
     * keys that are used for assertion.
     * @type {Array<string>}
     * @memberof DidIdDocument
     */
    'assertionMethod': Array<string>;
    /**
     * keys that are used for modification.
     * @type {Array<string>}
     * @memberof DidIdDocument
     */
    'modification': Array<string>;
    /**
     * services that are connected with this did.
     * @type {Array<DidService>}
     * @memberof DidIdDocument
     */
    'service': Array<DidService>;
    /**
     * Roles that are connected with this did, e.g. is this did authorized
     * @type {Array<DidRoles>}
     * @memberof DidIdDocument
     */
    'role': Array<DidRoles>;
}
/**
 * 
 * @export
 * @interface DidIdStructure
 */
export interface DidIdStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidIdStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidIdStructure
     */
    'controller'?: DidStructureController;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidIdStructure
     */
    'role'?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidIdStructure
     */
    'verificationMethod'?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidIdStructure
     */
    'service'?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'authentication'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'assertionMethod'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'keyAgreement'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdStructure
     */
    'modification'?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidIdTransaction
 */
export interface DidIdTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidIdTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidIdTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidIdTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidIdTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidIdTransactionValues}
     * @memberof DidIdTransaction
     */
    'values': DidIdTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidIdTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidIdTransaction
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DidIdTransactionBody
 */
export interface DidIdTransactionBody {
    /**
     * Version number of the transaction.
     * @type {number}
     * @memberof DidIdTransactionBody
     */
    'version': number;
    /**
     * timestamp when transaction was created.
     * @type {string}
     * @memberof DidIdTransactionBody
     */
    'date': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof DidIdTransactionBody
     */
    'type': TransactionType;
    /**
     * 
     * @type {DidIdTransactionBodyValue}
     * @memberof DidIdTransactionBody
     */
    'value': DidIdTransactionBodyValue;
}
/**
 * elements of the did document
 * @export
 * @interface DidIdTransactionBodyValue
 */
export interface DidIdTransactionBodyValue {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidIdTransactionBodyValue
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidIdTransactionBodyValue
     */
    'controller'?: DidStructureController;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidIdTransactionBodyValue
     */
    'role'?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidIdTransactionBodyValue
     */
    'verificationMethod'?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidIdTransactionBodyValue
     */
    'service'?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'authentication'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'assertionMethod'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'keyAgreement'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionBodyValue
     */
    'modification'?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidIdTransactionDto
 */
export interface DidIdTransactionDto {
    /**
     * Version number of the base transaction.
     * @type {number}
     * @memberof DidIdTransactionDto
     */
    'version': number;
    /**
     * 
     * @type {DidIdTransactionBody}
     * @memberof DidIdTransactionDto
     */
    'body': DidIdTransactionBody;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof DidIdTransactionDto
     */
    'metadata': TransactionMetadata;
    /**
     * 
     * @type {SignatureInfo}
     * @memberof DidIdTransactionDto
     */
    'signature': SignatureInfo;
}
/**
 * Values of the transaction
 * @export
 * @interface DidIdTransactionValues
 */
export interface DidIdTransactionValues {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidIdTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidIdTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * 
     * @type {RoleManage}
     * @memberof DidIdTransactionValues
     */
    'role'?: RoleManage;
    /**
     * 
     * @type {VerificationMethod}
     * @memberof DidIdTransactionValues
     */
    'verificationMethod'?: VerificationMethod;
    /**
     * 
     * @type {ServiceMange}
     * @memberof DidIdTransactionValues
     */
    'service'?: ServiceMange;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionValues
     */
    'authentication'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionValues
     */
    'assertionMethod'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionValues
     */
    'keyAgreement'?: VerificationRelationshipManage;
    /**
     * 
     * @type {VerificationRelationshipManage}
     * @memberof DidIdTransactionValues
     */
    'modification'?: VerificationRelationshipManage;
}
/**
 * 
 * @export
 * @interface DidPublicKey
 */
export interface DidPublicKey {
    /**
     * unique identifier of a key
     * @type {string}
     * @memberof DidPublicKey
     */
    'id': string;
    /**
     * 
     * @type {DidPublicKeyPublicKeyJwk}
     * @memberof DidPublicKey
     */
    'publicKeyJwk': DidPublicKeyPublicKeyJwk;
    /**
     * controller of the key
     * @type {string}
     * @memberof DidPublicKey
     */
    'controller': string;
    /**
     * 
     * @type {DidPublicKeyType}
     * @memberof DidPublicKey
     */
    'type': DidPublicKeyType;
}
/**
 * encoded key value
 * @export
 * @interface DidPublicKeyPublicKeyJwk
 */
export interface DidPublicKeyPublicKeyJwk {
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'kty'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'n'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'e'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'alg'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'crv'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'd'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'dp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'dq'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'k'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'p'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'qi'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'x'?: string;
    /**
     * 
     * @type {string}
     * @memberof DidPublicKeyPublicKeyJwk
     */
    'y'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DidPublicKeyType = {
    RsaVerificationKey2018: 'RsaVerificationKey2018'
} as const;

export type DidPublicKeyType = typeof DidPublicKeyType[keyof typeof DidPublicKeyType];


/**
 * 
 * @export
 * @enum {string}
 */

export const DidRoles = {
    Validator: 'Validator',
    Gateway: 'Gateway',
    Observer: 'Observer',
    Client: 'Client'
} as const;

export type DidRoles = typeof DidRoles[keyof typeof DidRoles];


/**
 * 
 * @export
 * @interface DidSchemaDocument
 */
export interface DidSchemaDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidSchemaDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidSchemaDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidSchemaDocument
     */
    'controller': Array<string>;
    /**
     * value of the schema
     * @type {string}
     * @memberof DidSchemaDocument
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface DidSchemaStructure
 */
export interface DidSchemaStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidSchemaStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidSchemaStructure
     */
    'controller'?: DidStructureController;
    /**
     * json schema to validate the data that should be parsed into the
     * @type {string}
     * @memberof DidSchemaStructure
     */
    'schema'?: string;
}
/**
 * 
 * @export
 * @interface DidSchemaTransaction
 */
export interface DidSchemaTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidSchemaTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidSchemaTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidSchemaTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidSchemaTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidSchemaTransactionValues}
     * @memberof DidSchemaTransaction
     */
    'values': DidSchemaTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidSchemaTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidSchemaTransaction
     */
    'id': string;
}
/**
 * Values of the transaction
 * @export
 * @interface DidSchemaTransactionValues
 */
export interface DidSchemaTransactionValues {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidSchemaTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidSchemaTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * json schema to validate the data that should be parsed into the
     * @type {string}
     * @memberof DidSchemaTransactionValues
     */
    'schema'?: string;
}
/**
 * 
 * @export
 * @interface DidService
 */
export interface DidService {
    /**
     * unique identifier of a service
     * @type {string}
     * @memberof DidService
     */
    'id': string;
    /**
     * name of the service
     * @type {string}
     * @memberof DidService
     */
    'type': string;
    /**
     * url to the service
     * @type {string}
     * @memberof DidService
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface DidStatusListDocument
 */
export interface DidStatusListDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidStatusListDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidStatusListDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidStatusListDocument
     */
    'controller': Array<string>;
    /**
     * enocded bitstring
     * @type {string}
     * @memberof DidStatusListDocument
     */
    'encodedList': string;
    /**
     * purpose of the list
     * @type {string}
     * @memberof DidStatusListDocument
     */
    'statusPurpose': DidStatusListDocumentStatusPurpose;
}

export const DidStatusListDocumentStatusPurpose = {
    revocation: 'revocation',
    suspension: 'suspension'
} as const;

export type DidStatusListDocumentStatusPurpose = typeof DidStatusListDocumentStatusPurpose[keyof typeof DidStatusListDocumentStatusPurpose];

/**
 * 
 * @export
 * @interface DidStatusListStructure
 */
export interface DidStatusListStructure {
    /**
     * unique identifier of a statuslist
     * @type {string}
     * @memberof DidStatusListStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidStatusListStructure
     */
    'controller'?: DidStructureController;
    /**
     * enocded bitstring
     * @type {string}
     * @memberof DidStatusListStructure
     */
    'encodedList'?: string;
    /**
     * 
     * @type {StatusPurpose}
     * @memberof DidStatusListStructure
     */
    'statusPurpose'?: StatusPurpose;
}
/**
 * 
 * @export
 * @interface DidStatusListTransaction
 */
export interface DidStatusListTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidStatusListTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidStatusListTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidStatusListTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidStatusListTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidStatusListTransactionValues}
     * @memberof DidStatusListTransaction
     */
    'values': DidStatusListTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidStatusListTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidStatusListTransaction
     */
    'id': string;
}
/**
 * Values of the transaction
 * @export
 * @interface DidStatusListTransactionValues
 */
export interface DidStatusListTransactionValues {
    /**
     * unique identifier of a statuslist
     * @type {string}
     * @memberof DidStatusListTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidStatusListTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * enocded bitstring
     * @type {string}
     * @memberof DidStatusListTransactionValues
     */
    'encodedList'?: string;
    /**
     * 
     * @type {StatusPurpose}
     * @memberof DidStatusListTransactionValues
     */
    'statusPurpose'?: StatusPurpose;
}
/**
 * 
 * @export
 * @interface DidStructure
 */
export interface DidStructure {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidStructure
     */
    'controller'?: DidStructureController;
}
/**
 * Did that controls this did.
 * @export
 * @interface DidStructureController
 */
export interface DidStructureController {
    /**
     * id that should be added to the controller list.
     * @type {Array<string>}
     * @memberof DidStructureController
     */
    'add'?: Array<string>;
    /**
     * id that should be removed from the controller list.
     * @type {Array<string>}
     * @memberof DidStructureController
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DidTemplateDocument
 */
export interface DidTemplateDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidTemplateDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidTemplateDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidTemplateDocument
     */
    'controller': Array<string>;
    /**
     * 
     * @type {DidTemplateDocumentCompression}
     * @memberof DidTemplateDocument
     */
    'compression': DidTemplateDocumentCompression;
    /**
     * value of the template
     * @type {string}
     * @memberof DidTemplateDocument
     */
    'template': string;
    /**
     * schema of the input
     * @type {string}
     * @memberof DidTemplateDocument
     */
    'schemaId': string;
}
/**
 * information about the compression
 * @export
 * @interface DidTemplateDocumentCompression
 */
export interface DidTemplateDocumentCompression {
    /**
     * 
     * @type {CompressionType}
     * @memberof DidTemplateDocumentCompression
     */
    'type': CompressionType;
    /**
     * Json encoded information that are required for this kind of compression.
     * @type {string}
     * @memberof DidTemplateDocumentCompression
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DidTemplateStructure
 */
export interface DidTemplateStructure {
    /**
     * unique identifier of a template
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidTemplateStructure
     */
    'controller'?: DidStructureController;
    /**
     * template that should be used.
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'template'?: string;
    /**
     * did of the schema the template is based on
     * @type {string}
     * @memberof DidTemplateStructure
     */
    'schemaId'?: string;
    /**
     * 
     * @type {Compression}
     * @memberof DidTemplateStructure
     */
    'compression'?: Compression;
}
/**
 * 
 * @export
 * @interface DidTemplateTransaction
 */
export interface DidTemplateTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidTemplateTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidTemplateTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidTemplateTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidTemplateTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidTemplateTransactionValues}
     * @memberof DidTemplateTransaction
     */
    'values': DidTemplateTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidTemplateTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidTemplateTransaction
     */
    'id': string;
}
/**
 * Values of the transaction
 * @export
 * @interface DidTemplateTransactionValues
 */
export interface DidTemplateTransactionValues {
    /**
     * unique identifier of a template
     * @type {string}
     * @memberof DidTemplateTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidTemplateTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * template that should be used.
     * @type {string}
     * @memberof DidTemplateTransactionValues
     */
    'template'?: string;
    /**
     * did of the schema the template is based on
     * @type {string}
     * @memberof DidTemplateTransactionValues
     */
    'schemaId'?: string;
    /**
     * 
     * @type {Compression}
     * @memberof DidTemplateTransactionValues
     */
    'compression'?: Compression;
}
/**
 * 
 * @export
 * @interface DidTransaction
 */
export interface DidTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidTransactionValues}
     * @memberof DidTransaction
     */
    'values': DidTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidTransaction
     */
    'id': string;
}
/**
 * Blockinformation
 * @export
 * @interface DidTransactionBlock
 */
export interface DidTransactionBlock {
    /**
     * id of the block
     * @type {number}
     * @memberof DidTransactionBlock
     */
    'id': number;
    /**
     * time when the block got persisted
     * @type {string}
     * @memberof DidTransactionBlock
     */
    'createdAt': string;
    /**
     * time when the transaction was persisted in an imported blockchain
     * @type {string}
     * @memberof DidTransactionBlock
     */
    'imported'?: string;
}
/**
 * Signature of the hash.
 * @export
 * @interface DidTransactionSignature
 */
export interface DidTransactionSignature {
    /**
     * 
     * @type {SignatureType}
     * @memberof DidTransactionSignature
     */
    'type': SignatureType;
    /**
     * signature of the document values
     * @type {Array<SignatureDto>}
     * @memberof DidTransactionSignature
     */
    'values': Array<SignatureDto>;
}
/**
 * Values of the transaction
 * @export
 * @interface DidTransactionValues
 */
export interface DidTransactionValues {
    /**
     * unique identifier of a did
     * @type {string}
     * @memberof DidTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidTransactionValues
     */
    'controller'?: DidStructureController;
}
/**
 * 
 * @export
 * @interface DidVisualRepresentationDocument
 */
export interface DidVisualRepresentationDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DidVisualRepresentationDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DidVisualRepresentationDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DidVisualRepresentationDocument
     */
    'controller': Array<string>;
    /**
     * array of presentations that belong to the did document.
     * @type {Array<Presentation>}
     * @memberof DidVisualRepresentationDocument
     */
    'presentation': Array<Presentation>;
}
/**
 * 
 * @export
 * @interface DidVisualRepresentationStructure
 */
export interface DidVisualRepresentationStructure {
    /**
     * unique identifier of a visualrepresentation
     * @type {string}
     * @memberof DidVisualRepresentationStructure
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidVisualRepresentationStructure
     */
    'controller'?: DidStructureController;
    /**
     * 
     * @type {DidVisualRepresentationStructurePresentation}
     * @memberof DidVisualRepresentationStructure
     */
    'presentation'?: DidVisualRepresentationStructurePresentation;
}
/**
 * Presentation that should be connected with the did.
 * @export
 * @interface DidVisualRepresentationStructurePresentation
 */
export interface DidVisualRepresentationStructurePresentation {
    /**
     * List of presentations that should be added to the did document.
     * @type {Array<Presentation>}
     * @memberof DidVisualRepresentationStructurePresentation
     */
    'add'?: Array<Presentation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DidVisualRepresentationStructurePresentation
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DidVisualRepresentationTransaction
 */
export interface DidVisualRepresentationTransaction {
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidVisualRepresentationTransaction
     */
    'signature': DidTransactionSignature;
    /**
     * 
     * @type {DidTransactionBlock}
     * @memberof DidVisualRepresentationTransaction
     */
    'block': DidTransactionBlock;
    /**
     * Timestamp when the element was created.
     * @type {string}
     * @memberof DidVisualRepresentationTransaction
     */
    'createdAt': string;
    /**
     * Type of the transaction
     * @type {string}
     * @memberof DidVisualRepresentationTransaction
     */
    'type': string;
    /**
     * 
     * @type {DidVisualRepresentationTransactionValues}
     * @memberof DidVisualRepresentationTransaction
     */
    'values': DidVisualRepresentationTransactionValues;
    /**
     * 
     * @type {DidTransactionSignature}
     * @memberof DidVisualRepresentationTransaction
     */
    'didDocumentSignature': DidTransactionSignature;
    /**
     * 
     * @type {string}
     * @memberof DidVisualRepresentationTransaction
     */
    'id': string;
}
/**
 * Values of the transaction
 * @export
 * @interface DidVisualRepresentationTransactionValues
 */
export interface DidVisualRepresentationTransactionValues {
    /**
     * unique identifier of a visualrepresentation
     * @type {string}
     * @memberof DidVisualRepresentationTransactionValues
     */
    'id': string;
    /**
     * 
     * @type {DidStructureController}
     * @memberof DidVisualRepresentationTransactionValues
     */
    'controller'?: DidStructureController;
    /**
     * 
     * @type {DidVisualRepresentationStructurePresentation}
     * @memberof DidVisualRepresentationTransactionValues
     */
    'presentation'?: DidVisualRepresentationStructurePresentation;
}
/**
 * 
 * @export
 * @interface DocResponse
 */
export interface DocResponse {
    /**
     * 
     * @type {DocResponseDocument}
     * @memberof DocResponse
     */
    'document': DocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof DocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof DocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface DocResponseDocument
 */
export interface DocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof DocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof DocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof DocResponseDocument
     */
    'controller': Array<string>;
}
/**
 * Metadata of the document
 * @export
 * @interface DocResponseMetaData
 */
export interface DocResponseMetaData {
    /**
     * 
     * @type {string}
     * @memberof DocResponseMetaData
     */
    'updated'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocResponseMetaData
     */
    'deactivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocResponseMetaData
     */
    'nextUpdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocResponseMetaData
     */
    'versionId': number;
    /**
     * 
     * @type {number}
     * @memberof DocResponseMetaData
     */
    'nextVersionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocResponseMetaData
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof DocResponseMetaData
     */
    'imported'?: string;
}
/**
 * signatures of the parsed document
 * @export
 * @interface DocResponseSignatures
 */
export interface DocResponseSignatures {
    /**
     * 
     * @type {SignatureType}
     * @memberof DocResponseSignatures
     */
    'type': SignatureType;
    /**
     * signature of the document values
     * @type {Array<SignatureDto>}
     * @memberof DocResponseSignatures
     */
    'values': Array<SignatureDto>;
}
/**
 * 
 * @export
 * @interface GenesisBlock
 */
export interface GenesisBlock {
    /**
     * index of the block
     * @type {number}
     * @memberof GenesisBlock
     */
    'index': number;
    /**
     * hash of the previous block
     * @type {string}
     * @memberof GenesisBlock
     */
    'previousHash': string;
    /**
     * merkle root hash
     * @type {string}
     * @memberof GenesisBlock
     */
    'hash': string;
    /**
     * timestamp of the block
     * @type {string}
     * @memberof GenesisBlock
     */
    'timestamp': string;
    /**
     * transactions that are included in this block
     * @type {Array<DidIdTransactionDto>}
     * @memberof GenesisBlock
     */
    'transactions': Array<DidIdTransactionDto>;
    /**
     * version of this block
     * @type {number}
     * @memberof GenesisBlock
     */
    'version': number;
    /**
     * signatures of the validators that accepted the block
     * @type {Array<SignatureDto>}
     * @memberof GenesisBlock
     */
    'signatures': Array<SignatureDto>;
    /**
     * 
     * @type {GenesisBlockProposer}
     * @memberof GenesisBlock
     */
    'proposer': GenesisBlockProposer;
    /**
     * 
     * @type {Array<SignatureDto>}
     * @memberof GenesisBlock
     */
    'stateSignatures': Array<SignatureDto>;
    /**
     * 
     * @type {string}
     * @memberof GenesisBlock
     */
    'stateRootHash': string;
}
/**
 * validator that proposed the block
 * @export
 * @interface GenesisBlockProposer
 */
export interface GenesisBlockProposer {
    /**
     * Identifier of the issuer and the used key
     * @type {string}
     * @memberof GenesisBlockProposer
     */
    'identifier': string;
    /**
     * The actual signature as a hex encoded string.
     * @type {string}
     * @memberof GenesisBlockProposer
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface HashDocResponse
 */
export interface HashDocResponse {
    /**
     * 
     * @type {HashDocResponseDocument}
     * @memberof HashDocResponse
     */
    'document': HashDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof HashDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof HashDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface HashDocResponseDocument
 */
export interface HashDocResponseDocument {
    /**
     * Hash of the file.
     * @type {string}
     * @memberof HashDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof HashDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof HashDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * Used algorithm for the hash.
     * @type {string}
     * @memberof HashDocResponseDocument
     */
    'algorithm': string;
    /**
     * Timestamp when the hash was revoked.
     * @type {string}
     * @memberof HashDocResponseDocument
     */
    'revoked'?: string;
}
/**
 * 
 * @export
 * @interface IdDocResponse
 */
export interface IdDocResponse {
    /**
     * 
     * @type {IdDocResponseDocument}
     * @memberof IdDocResponse
     */
    'document': IdDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof IdDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof IdDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface IdDocResponseDocument
 */
export interface IdDocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof IdDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof IdDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof IdDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * array of keys that belong to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof IdDocResponseDocument
     */
    'verificationMethod': Array<DidPublicKey>;
    /**
     * keys that are used for authentication.
     * @type {Array<string>}
     * @memberof IdDocResponseDocument
     */
    'authentication': Array<string>;
    /**
     * keys that are used for assertion.
     * @type {Array<string>}
     * @memberof IdDocResponseDocument
     */
    'assertionMethod': Array<string>;
    /**
     * keys that are used for modification.
     * @type {Array<string>}
     * @memberof IdDocResponseDocument
     */
    'modification': Array<string>;
    /**
     * services that are connected with this did.
     * @type {Array<DidService>}
     * @memberof IdDocResponseDocument
     */
    'service': Array<DidService>;
    /**
     * Roles that are connected with this did, e.g. is this did authorized
     * @type {Array<DidRoles>}
     * @memberof IdDocResponseDocument
     */
    'role': Array<DidRoles>;
}
/**
 * 
 * @export
 * @interface InviteNode
 */
export interface InviteNode {
    /**
     * id of the did
     * @type {string}
     * @memberof InviteNode
     */
    'id': string;
    /**
     * Secret token
     * @type {string}
     * @memberof InviteNode
     */
    'secret': string;
    /**
     * Url of the node endpoint
     * @type {string}
     * @memberof InviteNode
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface Presentation
 */
export interface Presentation {
    /**
     * unique identifier of a presentation
     * @type {string}
     * @memberof Presentation
     */
    'id': string;
    /**
     * 
     * @type {PresentationType}
     * @memberof Presentation
     */
    'type': PresentationType;
    /**
     * resolvable link to request the content
     * @type {string}
     * @memberof Presentation
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface PresentationMange
 */
export interface PresentationMange {
    /**
     * List of presentations that should be added to the did document.
     * @type {Array<Presentation>}
     * @memberof PresentationMange
     */
    'add'?: Array<Presentation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PresentationMange
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PresentationType = {
    pdf: 'pdf',
    html: 'html'
} as const;

export type PresentationType = typeof PresentationType[keyof typeof PresentationType];


/**
 * 
 * @export
 * @interface PublicKeyJwkDto
 */
export interface PublicKeyJwkDto {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'kty'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'n'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'e'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'alg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'crv'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'd'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'dp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'dq'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'k'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'p'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'q'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'qi'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'x'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyJwkDto
     */
    'y'?: string;
}
/**
 * 
 * @export
 * @interface RoleManage
 */
export interface RoleManage {
    /**
     * roles that should be added to the did
     * @type {Array<DidRoles>}
     * @memberof RoleManage
     */
    'add'?: Array<DidRoles>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SchemaDocResponse
 */
export interface SchemaDocResponse {
    /**
     * 
     * @type {SchemaDocResponseDocument}
     * @memberof SchemaDocResponse
     */
    'document': SchemaDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof SchemaDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof SchemaDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface SchemaDocResponseDocument
 */
export interface SchemaDocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof SchemaDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof SchemaDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof SchemaDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * value of the schema
     * @type {string}
     * @memberof SchemaDocResponseDocument
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ServiceMange
 */
export interface ServiceMange {
    /**
     * List of services that should be added to the did document.
     * @type {Array<DidService>}
     * @memberof ServiceMange
     */
    'add'?: Array<DidService>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceMange
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
    /**
     * Identifier of the issuer and the used key
     * @type {string}
     * @memberof SignatureDto
     */
    'identifier': string;
    /**
     * The actual signature as a hex encoded string.
     * @type {string}
     * @memberof SignatureDto
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SignatureInfo
 */
export interface SignatureInfo {
    /**
     * 
     * @type {SignatureType}
     * @memberof SignatureInfo
     */
    'type': SignatureType;
    /**
     * signature of the document values
     * @type {Array<SignatureDto>}
     * @memberof SignatureInfo
     */
    'values': Array<SignatureDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SignatureType = {
    Single: 'Single',
    Multi: 'Multi'
} as const;

export type SignatureType = typeof SignatureType[keyof typeof SignatureType];


/**
 * 
 * @export
 * @interface StatusListDocResponse
 */
export interface StatusListDocResponse {
    /**
     * 
     * @type {StatusListDocResponseDocument}
     * @memberof StatusListDocResponse
     */
    'document': StatusListDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof StatusListDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof StatusListDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface StatusListDocResponseDocument
 */
export interface StatusListDocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof StatusListDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof StatusListDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof StatusListDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * enocded bitstring
     * @type {string}
     * @memberof StatusListDocResponseDocument
     */
    'encodedList': string;
    /**
     * purpose of the list
     * @type {string}
     * @memberof StatusListDocResponseDocument
     */
    'statusPurpose': StatusListDocResponseDocumentStatusPurpose;
}

export const StatusListDocResponseDocumentStatusPurpose = {
    revocation: 'revocation',
    suspension: 'suspension'
} as const;

export type StatusListDocResponseDocumentStatusPurpose = typeof StatusListDocResponseDocumentStatusPurpose[keyof typeof StatusListDocResponseDocumentStatusPurpose];

/**
 * 
 * @export
 * @enum {string}
 */

export const StatusPurpose = {
    revocation: 'revocation',
    suspension: 'suspension'
} as const;

export type StatusPurpose = typeof StatusPurpose[keyof typeof StatusPurpose];


/**
 * 
 * @export
 * @interface TemplateDocResponse
 */
export interface TemplateDocResponse {
    /**
     * 
     * @type {TemplateDocResponseDocument}
     * @memberof TemplateDocResponse
     */
    'document': TemplateDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof TemplateDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof TemplateDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface TemplateDocResponseDocument
 */
export interface TemplateDocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof TemplateDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof TemplateDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof TemplateDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * 
     * @type {DidTemplateDocumentCompression}
     * @memberof TemplateDocResponseDocument
     */
    'compression': DidTemplateDocumentCompression;
    /**
     * value of the template
     * @type {string}
     * @memberof TemplateDocResponseDocument
     */
    'template': string;
    /**
     * schema of the input
     * @type {string}
     * @memberof TemplateDocResponseDocument
     */
    'schemaId': string;
}
/**
 * 
 * @export
 * @interface TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * Version number of the metadata.
     * @type {number}
     * @memberof TransactionMetadata
     */
    'version': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Hash: 'Hash',
    Did: 'Did',
    Schema: 'Schema',
    Template: 'Template',
    StatusList: 'StatusList',
    VisualRepresentation: 'VisualRepresentation'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface VerificationMethod
 */
export interface VerificationMethod {
    /**
     * List of public keys that should be added to the did document.
     * @type {Array<DidPublicKey>}
     * @memberof VerificationMethod
     */
    'add'?: Array<DidPublicKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationMethod
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerificationRelationshipManage
 */
export interface VerificationRelationshipManage {
    /**
     * id that should be removed from the list
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    'add'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationRelationshipManage
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VisualRepresentationDocResponse
 */
export interface VisualRepresentationDocResponse {
    /**
     * 
     * @type {VisualRepresentationDocResponseDocument}
     * @memberof VisualRepresentationDocResponse
     */
    'document': VisualRepresentationDocResponseDocument;
    /**
     * 
     * @type {DocResponseSignatures}
     * @memberof VisualRepresentationDocResponse
     */
    'signatures': DocResponseSignatures;
    /**
     * 
     * @type {DocResponseMetaData}
     * @memberof VisualRepresentationDocResponse
     */
    'metaData': DocResponseMetaData;
}
/**
 * parsed did document
 * @export
 * @interface VisualRepresentationDocResponseDocument
 */
export interface VisualRepresentationDocResponseDocument {
    /**
     * unique identifier of a did.
     * @type {string}
     * @memberof VisualRepresentationDocResponseDocument
     */
    'id': string;
    /**
     * schemas that define the document.
     * @type {Array<string>}
     * @memberof VisualRepresentationDocResponseDocument
     */
    '@context': Array<string>;
    /**
     * unique identifiers of the controller.
     * @type {Array<string>}
     * @memberof VisualRepresentationDocResponseDocument
     */
    'controller': Array<string>;
    /**
     * array of presentations that belong to the did document.
     * @type {Array<Presentation>}
     * @memberof VisualRepresentationDocResponseDocument
     */
    'presentation': Array<Presentation>;
}

/**
 * DefaultObserverApi - axios parameter creator
 * @export
 */
export const DefaultObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusControllerIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultObserverApi - functional programming interface
 * @export
 */
export const DefaultObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prometheusControllerIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prometheusControllerIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultObserverApi - factory interface
 * @export
 */
export const DefaultObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultObserverApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusControllerIndex(options?: any): AxiosPromise<void> {
            return localVarFp.prometheusControllerIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultObserverApi - object-oriented interface
 * @export
 * @class DefaultObserverApi
 * @extends {BaseAPI}
 */
export class DefaultObserverApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultObserverApi
     */
    public prometheusControllerIndex(options?: AxiosRequestConfig) {
        return DefaultObserverApiFp(this.configuration).prometheusControllerIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DidObserverApi - axios parameter creator
 * @export
 */
export const DidObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGenesis: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/did/genesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerGetDoc', 'id', id)
            const localVarPath = `/did/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.089Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerGetTransactions', 'id', id)
            const localVarPath = `/did/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerDidControllerMetaData', 'id', id)
            const localVarPath = `/did/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DidObserverApi - functional programming interface
 * @export
 */
export const DidObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DidObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGenesis(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenesisBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGenesis(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.089Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidIdTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerDidControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DidObserverApi - factory interface
 * @export
 */
export const DidObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DidObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the genesis block to build the chain of trust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGenesis(options?: any): AxiosPromise<GenesisBlock> {
            return localVarFp.observerDidControllerGenesis(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<IdDocResponse> {
            return localVarFp.observerDidControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.089Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidIdTransaction>> {
            return localVarFp.observerDidControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.090Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerDidControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DidObserverApi - object-oriented interface
 * @export
 * @class DidObserverApi
 * @extends {BaseAPI}
 */
export class DidObserverApi extends BaseAPI {
    /**
     * 
     * @summary Returns the genesis block to build the chain of trust
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGenesis(options?: AxiosRequestConfig) {
        return DidObserverApiFp(this.configuration).observerDidControllerGenesis(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.090Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return DidObserverApiFp(this.configuration).observerDidControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.089Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return DidObserverApiFp(this.configuration).observerDidControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.090Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidObserverApi
     */
    public observerDidControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return DidObserverApiFp(this.configuration).observerDidControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashObserverApi - axios parameter creator
 * @export
 */
export const HashObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerHashControllerGetDoc', 'id', id)
            const localVarPath = `/hash/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerHashControllerGetTransactions', 'id', id)
            const localVarPath = `/hash/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.113Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerHashControllerMetaData', 'id', id)
            const localVarPath = `/hash/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashObserverApi - functional programming interface
 * @export
 */
export const HashObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerHashControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerHashControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerHashControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidHashTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerHashControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.113Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerHashControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerHashControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashObserverApi - factory interface
 * @export
 */
export const HashObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<HashDocResponse> {
            return localVarFp.observerHashControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.112Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidHashTransaction>> {
            return localVarFp.observerHashControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.113Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerHashControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerHashControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HashObserverApi - object-oriented interface
 * @export
 * @class HashObserverApi
 * @extends {BaseAPI}
 */
export class HashObserverApi extends BaseAPI {
    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.112Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashObserverApi
     */
    public observerHashControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return HashObserverApiFp(this.configuration).observerHashControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.112Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashObserverApi
     */
    public observerHashControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return HashObserverApiFp(this.configuration).observerHashControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.113Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashObserverApi
     */
    public observerHashControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return HashObserverApiFp(this.configuration).observerHashControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeObserverApi - axios parameter creator
 * @export
 */
export const NodeObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInit: async (inviteNode: InviteNode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteNode' is not null or undefined
            assertParamExists('httpObserverControllerInit', 'inviteNode', inviteNode)
            const localVarPath = `/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteNode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerRebuild: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rebuild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerReset: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeObserverApi - functional programming interface
 * @export
 */
export const NodeObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerInit(inviteNode: InviteNode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerInit(inviteNode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerRebuild(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerRebuild(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpObserverControllerReset(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpObserverControllerReset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeObserverApi - factory interface
 * @export
 */
export const NodeObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the type of the node and the service that was exposed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInformation(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pass an invite code to init this node.
         * @param {InviteNode} inviteNode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerInit(inviteNode: InviteNode, options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerInit(inviteNode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebuilds the pki and hash database based on the local blockchain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerRebuild(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerRebuild(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpObserverControllerReset(options?: any): AxiosPromise<void> {
            return localVarFp.httpObserverControllerReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeObserverApi - object-oriented interface
 * @export
 * @class NodeObserverApi
 * @extends {BaseAPI}
 */
export class NodeObserverApi extends BaseAPI {
    /**
     * 
     * @summary Returns the type of the node and the service that was exposed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerInformation(options?: AxiosRequestConfig) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pass an invite code to init this node.
     * @param {InviteNode} inviteNode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerInit(inviteNode: InviteNode, options?: AxiosRequestConfig) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerInit(inviteNode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebuilds the pki and hash database based on the local blockchain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerRebuild(options?: AxiosRequestConfig) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerRebuild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeObserverApi
     */
    public httpObserverControllerReset(options?: AxiosRequestConfig) {
        return NodeObserverApiFp(this.configuration).httpObserverControllerReset(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaObserverApi - axios parameter creator
 * @export
 */
export const SchemaObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerSchemaControllerGetDoc', 'id', id)
            const localVarPath = `/schema/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerSchemaControllerGetTransactions', 'id', id)
            const localVarPath = `/schema/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerSchemaControllerMetaData', 'id', id)
            const localVarPath = `/schema/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaObserverApi - functional programming interface
 * @export
 */
export const SchemaObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerSchemaControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerSchemaControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerSchemaControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidSchemaTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerSchemaControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerSchemaControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerSchemaControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaObserverApi - factory interface
 * @export
 */
export const SchemaObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<SchemaDocResponse> {
            return localVarFp.observerSchemaControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidSchemaTransaction>> {
            return localVarFp.observerSchemaControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.232Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerSchemaControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerSchemaControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaObserverApi - object-oriented interface
 * @export
 * @class SchemaObserverApi
 * @extends {BaseAPI}
 */
export class SchemaObserverApi extends BaseAPI {
    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.232Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaObserverApi
     */
    public observerSchemaControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return SchemaObserverApiFp(this.configuration).observerSchemaControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.232Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaObserverApi
     */
    public observerSchemaControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return SchemaObserverApiFp(this.configuration).observerSchemaControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.232Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaObserverApi
     */
    public observerSchemaControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return SchemaObserverApiFp(this.configuration).observerSchemaControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatuslistObserverApi - axios parameter creator
 * @export
 */
export const StatuslistObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerStatusListControllerGetDoc', 'id', id)
            const localVarPath = `/statuslist/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerStatusListControllerGetTransactions', 'id', id)
            const localVarPath = `/statuslist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerStatusListControllerMetaData', 'id', id)
            const localVarPath = `/statuslist/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatuslistObserverApi - functional programming interface
 * @export
 */
export const StatuslistObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatuslistObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerStatusListControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusListDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerStatusListControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerStatusListControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidStatusListTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerStatusListControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerStatusListControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerStatusListControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatuslistObserverApi - factory interface
 * @export
 */
export const StatuslistObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatuslistObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<StatusListDocResponse> {
            return localVarFp.observerStatusListControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidStatusListTransaction>> {
            return localVarFp.observerStatusListControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.266Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerStatusListControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerStatusListControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatuslistObserverApi - object-oriented interface
 * @export
 * @class StatuslistObserverApi
 * @extends {BaseAPI}
 */
export class StatuslistObserverApi extends BaseAPI {
    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.266Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatuslistObserverApi
     */
    public observerStatusListControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return StatuslistObserverApiFp(this.configuration).observerStatusListControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.266Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatuslistObserverApi
     */
    public observerStatusListControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return StatuslistObserverApiFp(this.configuration).observerStatusListControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.266Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatuslistObserverApi
     */
    public observerStatusListControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return StatuslistObserverApiFp(this.configuration).observerStatusListControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateObserverApi - axios parameter creator
 * @export
 */
export const TemplateObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerTemplateControllerGetDoc', 'id', id)
            const localVarPath = `/template/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerTemplateControllerGetTransactions', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerTemplateControllerMetaData', 'id', id)
            const localVarPath = `/template/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateObserverApi - functional programming interface
 * @export
 */
export const TemplateObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerTemplateControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerTemplateControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerTemplateControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidTemplateTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerTemplateControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerTemplateControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerTemplateControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateObserverApi - factory interface
 * @export
 */
export const TemplateObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<TemplateDocResponse> {
            return localVarFp.observerTemplateControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidTemplateTransaction>> {
            return localVarFp.observerTemplateControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.283Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerTemplateControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerTemplateControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateObserverApi - object-oriented interface
 * @export
 * @class TemplateObserverApi
 * @extends {BaseAPI}
 */
export class TemplateObserverApi extends BaseAPI {
    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.283Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateObserverApi
     */
    public observerTemplateControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return TemplateObserverApiFp(this.configuration).observerTemplateControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.283Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateObserverApi
     */
    public observerTemplateControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return TemplateObserverApiFp(this.configuration).observerTemplateControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.283Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateObserverApi
     */
    public observerTemplateControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return TemplateObserverApiFp(this.configuration).observerTemplateControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VisualRepresentationObserverApi - axios parameter creator
 * @export
 */
export const VisualRepresentationObserverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerGetDoc: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerVisualRepresentationControllerGetDoc', 'id', id)
            const localVarPath = `/visualrepresentation/{id}/doc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerGetTransactions: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerVisualRepresentationControllerGetTransactions', 'id', id)
            const localVarPath = `/visualrepresentation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerMetaData: async (id: string, versionTime?: string, versionId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('observerVisualRepresentationControllerMetaData', 'id', id)
            const localVarPath = `/visualrepresentation/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (versionTime !== undefined) {
                localVarQueryParameter['versionTime'] = versionTime;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisualRepresentationObserverApi - functional programming interface
 * @export
 */
export const VisualRepresentationObserverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualRepresentationObserverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerVisualRepresentationControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisualRepresentationDocResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerVisualRepresentationControllerGetDoc(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerVisualRepresentationControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DidVisualRepresentationTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerVisualRepresentationControllerGetTransactions(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observerVisualRepresentationControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observerVisualRepresentationControllerMetaData(id, versionTime, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisualRepresentationObserverApi - factory interface
 * @export
 */
export const VisualRepresentationObserverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisualRepresentationObserverApiFp(configuration)
    return {
        /**
         * 
         * @summary returns the did document to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] return the did document with this version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<VisualRepresentationDocResponse> {
            return localVarFp.observerVisualRepresentationControllerGetDoc(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the transaction to assemble a did document.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<Array<DidVisualRepresentationTransaction>> {
            return localVarFp.observerVisualRepresentationControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the did document metadata to a did.
         * @param {string} id identifier of the did.
         * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.303Z
         * @param {number} [versionId] only request transactions that belong to reach the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observerVisualRepresentationControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: any): AxiosPromise<void> {
            return localVarFp.observerVisualRepresentationControllerMetaData(id, versionTime, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualRepresentationObserverApi - object-oriented interface
 * @export
 * @class VisualRepresentationObserverApi
 * @extends {BaseAPI}
 */
export class VisualRepresentationObserverApi extends BaseAPI {
    /**
     * 
     * @summary returns the did document to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] return the did document that was present to 2022-09-07T08:40:48.303Z
     * @param {number} [versionId] return the did document with this version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualRepresentationObserverApi
     */
    public observerVisualRepresentationControllerGetDoc(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return VisualRepresentationObserverApiFp(this.configuration).observerVisualRepresentationControllerGetDoc(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the transaction to assemble a did document.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp like 2022-09-07T08:40:48.303Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualRepresentationObserverApi
     */
    public observerVisualRepresentationControllerGetTransactions(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return VisualRepresentationObserverApiFp(this.configuration).observerVisualRepresentationControllerGetTransactions(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the did document metadata to a did.
     * @param {string} id identifier of the did.
     * @param {string} [versionTime] only request transactions that are less than the given timestamp 2022-09-07T08:40:48.303Z
     * @param {number} [versionId] only request transactions that belong to reach the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualRepresentationObserverApi
     */
    public observerVisualRepresentationControllerMetaData(id: string, versionTime?: string, versionId?: number, options?: AxiosRequestConfig) {
        return VisualRepresentationObserverApiFp(this.configuration).observerVisualRepresentationControllerMetaData(id, versionTime, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


